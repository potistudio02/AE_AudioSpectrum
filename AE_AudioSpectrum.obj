--track0: 開始位置, 0, 2000, 100
--track1: 終了位置, 0, 2000, 1820
--track2: 周波数帯, 0, 1000, 100
--track3: 高さ, 0, 1000, 300

--dialog: 色/col, local color=0xffffff; 開始周波数, local startFrequency=0; 終了周波数, local endFrequency=600; サンプルレベル, local sampleLevel=3; オーディオオフセット, local audioOffset=0; 太さ, local thickness=10; ディスプレイオプション, local displayOption=0; サイドオプション, local sideOption=1;

-------- rikky_module インポート --------
package.cpath = package.cpath .. ";" .. obj.getinfo ("script_path"):match ("(.*\\).*\\") .. "?.dll"
local bool, rikky_module = pcall (require, "rikky_module")
if not bool then
	obj.load ("<s100>require rikky_module!")
	obj.draw()
	return
end

-------- 設定 --------
obj.setfont ("MS UI Gothic", 50, 0, 0xffffff)
obj.setoption ("drawtarget", "tempbuffer", obj.screen_w, obj.screen_h)

-------- 変数 --------
local startPoint = obj.track0 - obj.screen_w / 2
local endPoint = obj.track1 - obj.screen_w / 2
local frequencyBand = obj.track2
local height = obj.track3 / 10000

local totalLength = endPoint - startPoint

local currentFrame, totalFrame = rikky_module.getinfo ("frame")

local spectrumBuffer = {}

error = false

-------- 関数 --------
function ShowError (value, m)
	error = true
	obj.load ("text", "Error " .. value .. "! The value is too " .. m)
	obj.draw()
end

--/ 直線補間 /--
function Lerp (a, b, t)
	return a * (1 - t) + b * t
end

function LerpArray (array, at)
	local mod = at % 1
	local before = at - mod
	local after = before + 1

	return Lerp (array[before] or 0, array[after] or 0, mod)
end

--/ 曲線補間 /--
function Spline (a, b, c, d, t)
	local x, y = obj.interpolation (t, 0, a, 1, b, 2, c, 3, d)

	return y
end

function SplineArray (array, at)
	local mod = at % 1
	local before = at - mod
	local before1 = before - 1
	local after = before + 1
	local after1 = after + 1

	return Spline (array[before1] or 0, array[before] or 0, array[after] or 0, array[after1] or 0, mod)
end

-------- エラー表示 --------
if endPoint < startPoint then
	ShowError ("終了位置", "small for 開始位置")
end

if endFrequency < startFrequency then
	ShowError ("終了周波数", "small for 開始周波数")
end

if startFrequency < 0 then
	ShowError ("開始周波数", "small")
end

if endFrequency < 0 then
	ShowError ("終了周波数", "small")
end

if sampleLevel < 0 then
	ShowError ("サンプルレベル", "small")
end

if sampleLevel > 3 then
	ShowError ("サンプルレベル", "big")
end

if thickness < 0 then
	ShowError ("太さ", "small")
end

if displayOption < 0 then
	ShowError ("ディスプレイオプション", "small")
end

if displayOption > 2 then
	ShowError ("ディスプレイオプション", "big")
end

if sideOption < 0 then
	ShowError ("サイドオプション", "small")
end

if sideOption > 2 then
	ShowError ("サイドオプション", "big")
end

-------- メイン処理 -------
if not error then
	--/ AUDIO /--
	spectrumBuffer = rikky_module.audiobuffer (currentFrame + audioOffset, "FOURIER", "absolute", "monaural", 1024, sampleLevel, {startFrequency, endFrequency})
	local space = #spectrumBuffer / frequencyBand

	--/ 描画 /--
	obj.load ("figure", "円", color, thickness)

	if displayOption == 0 then
		for i = 0, frequencyBand - 1 do
			obj.draw (totalLength / (frequencyBand - 1) * i + startPoint, 0, 0)
		end
	end

	if displayOption ~= 1 then
		if sideOption ~= 2 then
			for i = 0, frequencyBand - 1 do
				obj.draw (totalLength / (frequencyBand - 1) * i + startPoint, SplineArray (spectrumBuffer, space * i) * -height, 0)
			end
		end

		if sideOption ~= 1 then
			for i = 0, frequencyBand - 1 do
				obj.draw (totalLength / (frequencyBand - 1) * i + startPoint, SplineArray (spectrumBuffer, space * i) * height, 0)
			end
		end
	end

	if displayOption ~= 2 then
		local S = {}
		for i = 1, 4 do
			S[i] = {}
			for j = 1, 2 do
				S[i][j] = 0
			end
		end

		obj.load ("figure", "四角形", color, 1)

		for i = 0, frequencyBand - 1 do
			S[1][1] = (totalLength / (frequencyBand - 1) * i + startPoint) - (thickness / 2)
			S[1][2] = SplineArray (spectrumBuffer, space * i) * height
			S[2][1] = (totalLength / (frequencyBand - 1) * i + startPoint) + (thickness / 2)
			S[2][2] = SplineArray (spectrumBuffer, space * i) * height

			S[3][1] = (totalLength / (frequencyBand - 1) * i + startPoint) + (thickness / 2)
			S[3][2] = 0
			S[4][1] = (totalLength / (frequencyBand - 1) * i + startPoint) - (thickness / 2)
			S[4][2] = 0

			if sideOption ~= 2 then
				obj.drawpoly (S[1][1], -S[1][2], 0, S[2][1], -S[2][2], 0, S[3][1], S[3][2], 0, S[4][1], S[4][2], 0)
			end

			if sideOption ~= 1 then
				obj.drawpoly (S[1][1], S[1][2], 0, S[2][1], S[2][2], 0, S[3][1], S[3][2], 0, S[4][1], S[4][2], 0)
			end
		end
	end
end

-------- 最終処理 --------
obj.load ("tempbuffer")
obj.effect()
